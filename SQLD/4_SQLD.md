# Subquery
- SELECT 내부에 SELECT ...
- 상대적으로 밖에있는 SELECT문은 Main Query
- 내부 SELECT문의 사용 => 가상 테이블 만드는 효과 (FROM구에 사용)

## 다중행/단일행(Single row subquery & Multi row subquery) 서브쿼리
- 단일행 서브쿼리 : 비교연산자인 > <= ... 사용, 반드시 한 행만 조회된다.
- 다중행 서브쿼리 : IN,ANY,ALL,EXISTS(다중행연산자)사용, 여러개의 행 조회

### 다중행 연산자
- IN : Main query의 비교조건이 Subquery의 결과 중 하나만 동일하면 참 (OR조건)
- ALL : 모두 동일해야 참 (< ALL : 하나라도 크면 참, > ALL : 하나라도 작으면 참)
- ANY : 하나 이상 동일하면 참
- EXISTS : 메인쿼리와 서브쿼리 결과가 하나라도 존재하면 참


### 스칼라 서브쿼리
- 반드시 한행, 한칼럼만 반환하는 서브쿼리로 여러행이 반환된다면 오류 발생

### 연관 서브쿼리
- 서브쿼리 내에서 메인 쿼리 내의 칼럼을 사용하는 것 의미

# JOIN
- 여러개의 릴레이션 => 새로운 릴레이션
  - 교집합을 만드는 것이 기본
## EQUI JOIN
- 내부적으로 두개의 테이블을 어떻게 연결했는지 확인 가능 (FK를 사용해 연결한것 생각하면 됨)
- 해시조인을 사용할 수 있다. 여기서 해시함수는 테이블을 해시 메모리에 적재한 후 해시 함수로써 연결하는 방법이다.

## INTERSECT
- 두 테이블의 교집합을 구함.(공통값)

## Non-EQUI JOIN 
- 정확하게 일치하지 않는 것을 조인하는 것으로, > < 등을 사용해 조인한다.

## OUTER JOIN
- 테이블 간 교집합을 조회하고, 한쪽 테이블에만 있는 데이터도 조회한다.
  - 즉, 교집합 외에도 비교한 필드에서 다른 값을 가진것 또한 포함한다는 말

## LEFT OUTER JOIN
- 두개의 테이블에서 같은 것을 조회하고, 왼쪽 테이블에만 있는 것을 포함해서 조회한다.
  
CROSS JOIN
- 조건 없이 두개의 테이블을 하나로 조인 (조인구가 없기에, 카테시안 곱 발생)

## UNION
- 두개의 테이블을 하나로 만드는 연산
- 두 테이블의 칼럼 수, 데이터 형식 모두 일치해야 한다
- 이 과정에서 중복된 데이터를 제거한다. (Sort과정 발생)
### UNION ALL
- UNION ALL 은 UNION과 달리 중복을 제거하거나 정렬을 유발하지 않는다
- 두 개의 테이블을 하나로 합치는 것이다.

## MINUS
- 차집합을 조회한다. (My-SQL에서는 EXCEPT로 연산 가능)

# 그룹연산
## ROLLUP ?
- GROUP BY의 칼럼에 대해서 Subtotal을 만들어 준다.
- ROLL UP시, GROUP BY구에 칼럼이 두 개 이상 오면 순서에 따라 결과가 달라짐

## GROUPING
- ROLLUP, CUBE, GROUPING SETS에서 생성되는 합계 값을 구분하기 위해 만들어진 함수
- 소계, 합계 등 계산되면 GROUPING 함수는 1을 반환하고, 그렇지 않으면 0을 반환한다.

## GROUPING SETS
- GROUPING SETS 함수는 GROUP BY에 나오는 칼럼의 순서와 관계 없이 다양한 소계를 만들 수 있다. (개별적으로 모두 처리한다.)

## CUBE
- 결합 가능한 모든 집계를 계산한다.
- 다차원 집계 제공 => 다양한 데이터 분석

## WINDOW_FUNCTION (164p)
- 행과 행 간 관계를 정의하기 위해서 제공되는 함수
- 순위, 합계, 평균, 행 위치 등 조작 가능
- 함수의 구조, WINDOWING은 책 참고

## RANK FUNCTION (166p)
- RANK : 특정항목 및 파티션에 대해 순위 계산
- DENSE_RANK : 동일 순위를 하나의 건수로 계산
- ROW_NUMBER : 동일 순위에 대해서 고유의 순위를 부여한다.

## 비율관련 함수 (172p)

## ROWID
- ORACLE DB에서 데이터를 구분하는 값
- 이를 통해 어떤 데이터파일의 어떤 블럭에 저장되어 있는지 알 수 있다. (입력 순서 또한 의미)

## 계층형 조회 (CONNECT BY), 178p
- 트리 형태의 구조로 질의를 수행하는 것
- LPAD로 트리 모양으로 볼 수 있다.
### 키워드
- START WITH : 전개 위치
- PRIOR : 부모=> 자식 or 자식=> 부모
- NOCYCLE
- Order siblings by : 동일 level 정렬

## PIVOT
- 행과 열을 바꾼다고 생각하면 된다. (행기반에서 열기반 : PIVOT, 그 반대는 UNPIVOT)

# 테이블 파티션
- 대용량의 테이블을 여러개의 데이터 파일에 분리, 저장 => 성능 개선

## Range Partition
- 값의 범위를 기준으로 여러개의 파티션으로 데이터를 나눠 저장

## List Partition
- 특정 값을 기준으로 분할

## Hash Partition
- 해시 함수를 사용해 데이터를 분할

# 정규표현식 (regexp)
- 주민번호 등 특정 규칙을 가지고 있는 데이터를 찾을 때 사용 가능

# 이론을 확인하는 기출 문제
1. EQUI JOIN : =으로 조인함. INNERJOIN사용하며, 교집합을 구하는 것.
2. EQUI JOIN의 특징으론 HASH JOIN을 사용할 수 있다는 것이다.
3. CROSS JOIN이 데이터의 행 수가 가장 많이 조회된다.
4. UNION의 경우에 합집합을 만들고 중복을 제거하며 정렬을 유발한다.
5. ORACLE에선 MINUS로, MS-SQL에선 EXCEPT로 차집합을 구한다.
6. 서브쿼리에서 FROM절엔 Inline view 작성한다.
7. ALL은 서브쿼리의 결과와 메인쿼리의 결과가 모두 동일해야 참을 반환한다.
8. Scala 서브쿼리는 반드시 한행과 한 칼럼만 반환한다.
9. ROLLUP의 경우, GROUP BY 칼럼에 대해 Subtotal을 만들어준다.
10. 윈도우 함수 중 LEAD는 특정 위치의 행을 가져오고, 기본값으로 1을 가지고 있다.
11. [:alnum:]은 정규표현식에서 알파벳과 숫자로 이루어진 것을 검색할 때 사용한다.
