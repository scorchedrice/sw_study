# 정규화
- 데이터의 일관성, 중복 최소화, 유연성을 위한 방법으로 데이터를 분해하는 과정
    - 데이터 분해로 중복을 제거하기에 유연성을 높인다.
    - 불필요한 데이터 입력 사전 방지 가능
- 정규화를 통해 비즈니스에 변화가 있더라도 데이터 모델의 변경을 최소화할 수 있다.
- 테이블을 분해하는 등의 과정으로 문제 진행 가능

## 정규화 절차
1. 제1정규화
- 속성의 원자성을 확보한다.
- 기본키(Primary) 설정
2. 제2정규화
- 기본키가 2개 이상의 속성으로 이루어진 경우, 부분 함수 종속성을 제거(분해)
3. 제3정규화
- 기본키를 제외한 칼럼 간의 종속성을 제거한다.
    - 즉, 이행 함수 종속성을 제거

### 제1정규화
- X => Y이면, Y는 X에 함수적으로 종속된다고 말한다. 즉 X가 바뀌면 Y가 바뀌는지를 확인한다.
- 이를 방지하기 위해 기본키의 기준을 잡는다.
    - 계좌번호, ID => 계좌명, 예수금, 관리점, 이름

### 제2정규화
- 부분 함수 종속성은 기본키가 2개 이상인 경우 발생한다.
    - 계좌번호와 ID를 기본키라고 두는 상황을 가정했을 때, ID가 바뀌면 회원 이름이 변경되는 상황이 발생한다. 이를 부분 함수 종속성이라고 한다.
- 이를 판단하고, 만약 이가 확인된다면, 분해를 진행해야 한다.
    - 계좌번호, ID => 계좌명, 예수금, 관리점
    - ID => 이름 (분해된 테이블)

### 제3정규화
- 이행 함수 종속성을 제거하는 과정이다.
    - 이행 함수 종속성 : 기본키를 제외한 칼럼간 종속성이 발생하는 경우
        - 관리점 코드 => 관리점
- 이와 같은 경우가 확인된다면, 이를 분리!

### BCNF(Boyce-Codd Normal Form)
- 학번, 과목번호를 기본키로 하고 교수를 가리키는 상황을 가정해보자.
    - 학번, 과목번호가 교수를 종속하고 있으나, 교수가 과목번호를 함수적으로 종속하는 경우가 존재. (분해 필요)

## Example
- 정규화 대상 테이블 예시 (82페이지)

# 정규화의 성능
## 정규화의 문제점
- SELECT시에 Join을 유발하기에, CPU/Memory의 사용이 필요 (부하)
    - 반 정규화의 존재 이유
        - 하지만 반 정규화 또한 문제점 있음!

# 반정규화
- 데이터의 중복을 허용해 Join을 줄여 성능 향상 목적
- 정규화로 수행 속도가 느려지는 문제를 개선하기 위함
- 다량의 범위를 자주 처리하거나 특정 범위의 데이터를 주로 처리하는 경우 등 사용
- 반정규화를 진행하기 전, 다른 방법이 있는지 검토할 필요성이 있다. (클러스터링, 인덱스 튜닝, 파티션 기법 등)

## 반정규화 기법
1. 계산된 칼럼 추가
- 총 판매액 등을 미리 계산해 추가
2. 테이블 수직 분할
- 하나의 테이블을 두개 이상의 테이블로 분할.
    - 칼럼의 분할 => 새로운 테이블
3. 테이블 수평 분할
- 값을 기준으로 테이블 분할
    - 필드명은 동일함
4. 테이블 병합
- 1대1 관계 테이블 => 병합
- 1대N 관계 테이블 => 병합
    - 중복 발생 급증하는 단점 존재
- 슈퍼타입 / 서브관계 발생시 통합하여 성능 개선

### 클러스터링
- 인덱스 정보를 저장할 때, 물리적으로 정렬해서 저장하는 방법
- 인접 블록을 연속적으로 읽기에 성능 향상

### 파티션 기법
- 논리적으로는 하나의 테이블이지만, 여러개의 데이터 파일에 분산 저장
    - Range Partition : 데이터 값의 범위를 기준으로 파티션 수행
    - List Partition : 특정한 값을 지정하여 파티션 수행
    - Hash Partition : 해시 함수를 적용하여 파티션을 수행
    - Composite Partition : 범위와 해시를 복합 사용
- 조회시 Access 범위 줄어들어 성능 향상
- 분할된 데이터 => Input/Output 성능 향상
- 독립적 백업 복구 가능

### 슈퍼타입, 서브타입
- 고객을 예시로 들자. 고객엔터티는 슈퍼타입, 개인 고객 / 법인 고객 등.. 은 서브타입
- OneToOne Type : 슈퍼타입과 서브타입을 개별 테이블로 도출, 조인 발생 많고 관리 어려운 단점
- Plus Type : 슈퍼타입과 서브타입 테이블로 도출, 조인발생 단점
- Single Type : 하나의 테이블로 도출, 입출력 성능이 나쁨

# 모델이 표현하는 트랜잭션의 이해
## 식별관계 (강한객체, 약한객체)
- 약한객체는 강한객체의 기본키를 Foreign Key로 가진다.
## 비식별관계
- 강한객체의 일반 필드를 약한객체는 FK로 가진다.

### 강한객체, 약한객체
- 강한객체는 누구에게도 지배되지 않는 독립적인 객체

# 이론을 확인하는 기출문제
1. 데이터 중복을 제거하여 데이터 모델의 유연성 향상
- 정규화, 3층스키마, 이상현상제거
2. 이행함수종속성 제거 : 제3정규화
3. 반정규화를 수행하는 경우
- SELECT 실행 속도 저하
- 집계 정보 요구
- 특정 범위 자주 조회
4. 반정규화 기법 중 특정값의 범위에 따라 분할하는 것 : 수평분할
5. SuperType, SubType 변환 과정 중 Join 성능이 가장 우수한 것은 : SingleType - 하나의 테이블로 생성하기에
6. 좋은 모델링의 조건 : 중복배제, Business Rule, 완전성
---------------
# 합격을 다지는 예상문제 (98p)
